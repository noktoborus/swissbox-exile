package fep;
option optimize_for = SPEED;
/*
 * |a|a|b|b|b|_|
 *  ^   ^__________ payload size
 *  |_________ packet type
 * _ - are reserved
 * all values in BE bytes order
 */


/*
 * Особенности
 Для записи и чтения еденица передачи: чанк
 На любой из запросов к севреру может прийти ответ Pending с тем же id
  Данный ответ является лишь указанием на то, что сервер принял запрос,
  но обработает его позже, следует ждать дальнейших указаний по этому же id

 * Последовательности
 Последовательность авторизации:
 S: ReqAuth
 C: Auth
 S: [Ok|Error|Pending]

 Последовательность инициализации:
 до момента отправки WantSync клинтом сообщения об обновлении не отсылаются
 C: WantSync (id = 30, session_id = 400)
 S: RootdirUpdate (id = 31, session_id = 400, no = 1, max = 3)
 S: DirectoryUpdate (id = 32, session_id = 400, no = 2, max = 3)
 S: (DirectoryUpdate)
 S: ...
 S: FileUpdate (id = 33, session_id = 400, no = 2, max = 3)
 S: (FileUpdate)
 S: End (id = 34, session_id = 400)
 ...

 Создание/удаление/переименование директории:
 C: DirectoryUpdate
 S: OkUpdate

 Последовательность записи:
 C: WriteAsk (id = 1000)
 S: OkWrite (id = 1000, session_id = 2344)
 C: xfer (session_id = 2344)
 C: xfer (session_id = 2344)
 ...
 C: End (session_id = 2344)
 C: WriteAsk...
 S: OkWrite...
 C: xfer...
 C: End...
 ...
 C: FileMeta (id = 1002)
 S: OkUpdate (id = 1002)

 Последовательность чтения:
 C: ReadAsk (id = 2051, session_id = 331)
 S: OkRead (id = 2051)
 S: xfer (id = 440, session_id = 331)
 S: xfer (id = 441, session_id = 331)
 ...
 S: End (id = 445, session_id = 331)

 Получение количества чанков и информацию по файлу:
 C: QueryChunks (id = 100, session_id = 200)
 S: FileMeta (id = 100)
 S: ResultChunk (id = 101, session_id = 200, chunk_no = 1, chunk_max = 3)
 S: ResultChunk (id = 102, session_id = 200, chunk_no = 2, chunk_max = 3)
 S: ResultChunk (id = 103, session_id = 200, chunk_no = 3, chunk_max = 3)
 S: End(id = 104, session_id = 200)

 Получение списка ревизий
 C: QueryRevisions (id = 107, session_id = 201, depth = 3, offset = 0)
 S: Ok (id = 107)
 S: ResultRevision (id = 108, session_id = 201, rev_no = 1, rev_max = 3)
 S: ResultRevision (id = 109, session_id = 201, rev_no = 2, rev_max = 3)
 S: ResultRevision (id = 110, session_id = 201, rev_no = 3, rev_max = 3)
 S: End(id = 111, session_id = 201)
*/

enum Type {
	tPing = 1;
	tPong = 2;
	tError = 3;
	tOk = 4;
	tPending = 5;
	tReqAuth = 6;
	tAuth = 7;
	txfer = 8;
	tReadAsk = 9;
	tWriteAsk = 10;
	tEnd = 11;
	tOkWrite = 12;
	tFileUpdate = 13;
	tRenameChunk = 14;
	tQueryChunks = 15;
	tResultChunk = 16;
	tQueryRevisions = 17;
	tResultRevision = 18;
	tDirectoryUpdate = 19;
	tFileMeta = 20;
	tWantSync = 21;
	tOkUpdate = 22;
	tRootdirUpdate = 23;
	tOkRead = 24;
}

/*

 Время в Ping/Pong указывается от начала эры Unix
 C: Ping
 S: Pong
 клиент указывает в Ping время генерации сообщения,
 а сервер время обработки
*/
message Pong {
	required uint64 id = 1;
	/* время из Ping */
	required uint64 sec = 2;
	required uint32 usec = 3;
	/* время на удалённом пире */
	required uint64 peer_sec = 4;
	required uint64 peer_usec = 5;
}

message Ping {
	required uint64 id = 1;
	/* секунды и микросекунды */
	required uint64 sec = 2;
	required uint32 usec = 3;
}

enum ReqAuthType {
	tHash = 0;
	tUserPassword = 1;
	tUserToken = 2;
	tKey = 3;
}

/* предложение сервера авторизироваться:
 * ожидаемые ответы: Auth */
message ReqAuth {
	required uint64 id = 1;
	/* информационный текст для пользователя */
	optional string text = 5;
}

/* запрос клиента авторизации
 * ожидаемые ответы: Ok, Error,
 * Pending: информационное сообщение, авторизация принята,
 * 		но проверку выполнить прямо сейчас не получится
 */
message Auth {
	required uint64 id = 1;
	required string domain = 2;
	/* поля для авторизации, только хеш, юзер/пароль, ключ */
	optional string authToken = 4;
	optional string username = 5;
	optional string password = 6;
	optional bytes key = 7;
	required ReqAuthType authType = 8;

	/* идентификация устройства */
	required uint64 device_id = 14;

}

/* общие ответы
	в поле requestType указывается тип сообщения
	на которое генерируется ответ
 */
message Error {
	required uint64 id = 1 [default = 0];
	optional string message = 3;
	/* количество оставшихся попыток до применения санкций
	   полезно, к примеру, для Auth
	   Если указан 0, то продолжение работы невозможно
	   в остальных случаях или используется счётчик или поле не указывается
	 */
	optional uint32 remain = 4;
}

message Ok {
	required uint64 id = 1;
}

/* подобный запрос уже выполняется
 или используется в качестве альтернативы пингу сервером к клиенту
 указывает на то, что запрос принят к обработке,
 но быть выполненым сейчас не может, дальнейшие распоряжения прийдут позже
 */
message Pending {
	required uint64 id = 1 [default = 0];
	/* стринги отладки */
	optional string debug = 999;
}

/* отмена операции */
message Cancel {
	required uint64 id = 1 [default = 0];
	optional string message = 2;
}

/*
	Переименование, удаление файлов
	Ответы:
		OkUpdate, Error, Pending
*/
message FileUpdate {
	required uint64 id = 1 [default = 0];

	/* идентификация файла по трём полям */
	required string rootdir_guid = 3;
	required string file_guid = 4;

	/* опциональные значения
	 если не переименование (enc_filename)
	 и не перемещение (directory_guid), то это удаление
	 */
	optional string enc_filename = 50;
	optional string directory_guid = 53;
	/* приходит только от сервера клиенту
	  при обновлении ревизии файла (enc_filename и directory_guid пустые)
	 */
	optional string revision_guid = 54;

	/* отправляется только сервером клиенту, содержит чекпоинт лога */
	optional uint64 checkpoint = 100;

	/* для ответа на WantSync */
	optional uint64 session_id = 201;
	/* количество и номер в пределах сессии */
	optional uint32 no = 202;
	optional uint32 max = 203;
}


/*
 Присылается после отправки всех чанков
 ревизии файла
 Ответы:
	OkUpdate: Всё нормально, можно продолжать
	Error: отмена
 */
message FileMeta {
	required uint64 id = 1 [default = 0];

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string revision_guid = 5;
	required string directory_guid = 6;
	/* количество чанков в файле */
	required uint32 chunks = 10;
	/* эти поля не обязательно отправлять с новой ревизией,
	  но если сервер не найдёт старые записи файла, в которых ключ есть,
	  то можно словить Error
	 */
	optional string enc_filename = 50;
	optional bytes key = 52;

	/* может быть пустым если файл новый */
	optional string parent_revision_guid = 87;
}

/*
 * Запрос разрешения на запись
 * ответы:
 *  Error: неудача
 *  OkWrite: запись разрешена
*/
message WriteAsk {
	required uint64 id = 1 [default = 0];
	/* требуемое пространство в байтах для сохранения,
		пространство резервируется и идентификатор резервации указывается
		в поле session_id в ответе OkWrite
	*/
	required uint64 size = 2;
	/* название рутдиры */
	required string rootdir_guid = 3;
	required string file_guid = 5;
	required string chunk_guid = 6;
	required string revision_guid = 7;
	/* sha256 хеш чанка */
	required bytes chunk_hash = 10;
}

message OkWrite {
	required uint64 id = 1 [default = 0];

	/*
		Номер сессии, внутри которой передаются куски чанка
		этот id используется в сообщении xfer, для того, что бы можно
		было передавать несколько файлов одновременно
	*/
	required uint32 session_id = 2;

}

/*
   Предложение сервера или клиента завершить сессию
*/
message End {
	required uint64 id = 1 [default = 0];
	/* важное поле: идентификатор запрошенного пространства
	   при запросе записи резервируется пространство
	   и этот идентификатор нужен для последующей записи в это пространство
	   */
	required uint32 session_id = 2;

	/* опциональное поле-контролёр: сколько пакетов было отослано в сессии */
	optional uint32 packets = 4;
}

/* ответ на запрос чтения */
message OkRead {
	required uint64 id = 1 [default = 0];
	
	required uint32 session_id = 2;

	required uint32 size = 5;
	required uint32 offset = 6;
}

/* 
 	Передача куска чанка.
	Если ошибок во время записи не произошло, подтверждение не отсылается.
	Иначе возвращается Error
 */
message xfer {
	required uint64 id = 1 [default = 0];
	/* идентификатор сессии передачи */
	required uint32 session_id = 2;
	/* смещение в чанке */
	required uint64 offset = 4;
	required bytes data = 6;
}

/* чтение */

/*
 запрос на чтение,
 возможные ответы:
 Error: невозможно начать передау
 Write: передача
*/
message ReadAsk {
	required uint64 id = 1 [default = 0];
	/* аналогично записи, резервируемая область у клиента */
	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string chunk_guid = 5;
}

message QueryRevisions {
	required uint64 id = 1 [default = 0];

	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	required string file_guid = 4;

	required uint32 depth = 5 [default = 3];
}

message ResultRevision {
	required uint64 id = 1 [default = 0];

	required uint32 session_id = 2;

	required string revision_guid = 3;
	/* аналог к ResultChunk.chunk_no/ResultChunk.chunk_max */
	required uint32 rev_no = 5;
	required uint32 rev_max = 6;
	
	optional string parent_revision_guid = 10;
}

/* запрос чанков для ревизии revision_guid
 Ответы:
 	FileMeta, Error
 */
message QueryChunks {
	required uint64 id = 1 [default = 1];

	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string revision_guid = 5;
}

/* ответ на QueryChunks */
message ResultChunk {
	required uint64 id = 1 [default = 1];

	required uint32 session_id = 2;

	required string chunk_guid = 5;
	/* общее количество подобных сообщений и номер текущего сообщения  */
	required uint32 chunk_no = 7;
	required uint32 chunk_max = 8;
	
	required bytes chunk_hash = 10;
}

/* используется для переноса чанка из другой ревизии в указанную */
message RenameChunk {
	required uint64 id = 1 [default = 0];
	required string rootdir_guid = 2;
	required string file_guid = 3;
	required string chunk_guid = 4;
	/* целевой гуид */
	required string to_chunk_guid = 5; 
	required string to_revision_guid = 6;
}

/* извещения
 * Извещения отправляются сервером клиенту
 * в случае отсутсвия поля id ответ не требуется
 */

/*
	сообщение о озменениях в структуре каталогов
 */
message DirectoryUpdate {
	required uint64 id = 1;
	required string rootdir_guid = 2;
	/* гуид директории */
	required string guid = 3;

	/* путь директории
	 имя указывается или для новых директорий или для переименования,
	 если не указан -- директория удаляется
	 */
	optional string path = 4;

	/* отправляется только сервером */
	optional uint64 checkpoint = 100;

	/* поля для ответа сервера на WantSync */
	optional uint64 session_id = 201;
	/* количество и номер в пределах сессии */
	optional uint32 no = 202;
	optional uint32 max = 203;
}

/* TODO:
   3. добавить обратку коллизий
   2. нотификация
   1. Мета (директории, хеши, всё такое)
 */

/*
	Хотет синка
	нотификационное сообщение, в ответ Ok или Error
	после чего пачками приходят сообщения Directory и FileUpdate
	ответы: Ok, Error
   */
message WantSync {
	required uint64 id = 1 [default = 0];

	/*
		WantSync должен быть на каждый rootdir,
		если rootdir не указан,
		то возвращается лог создания rootdir (список рутдир)
	*/
	optional string rootdir_guid = 3;
	/* чекпоинт для лога */
	required uint64 checkpoint = 5 [default = 0];

	/* номер сессии для DirectoryUpdate/FileUpdate */
	required uint64 session_id = 10;
}

/*
	положительный ответ для FileUpdate и DirectoryUpdate
  */
message OkUpdate {
	required uint64 id = 1 [default = 0];
	/* id состояния, в которое попала запись */
	required uint64 checkpoint = 5;
}


/* от сервера к клиенту
	извещение о обновлении состояния Rootdir
  */
message RootdirUpdate {
	required uint64 id = 1 [default = 0];
	required string rootdir_guid = 24;
	
	optional string name = 90;

	optional uint64 checkpoint = 100;
	optional uint32 no = 202;
	optional uint32 max = 203;
}
/*
TODO: добавить сообщение нотификации отдельных файлов
*/
