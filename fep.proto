package fep;
option optimize_for = SPEED;
/*
 * |a|a|b|b|b|_|
 *  ^   ^__________ payload size
 *  |_________ packet type
 * _ - are reserved
 * all values in BE bytes order
 */


/*
 * Особенности
 Для записи и чтения еденица передачи: чанк
 На любой из запросов к севреру может прийти ответ Pending с тем же id
  Данный ответ является лишь указанием на то, что сервер принял запрос,
  но обработает его позже, следует ждать дальнейших указаний по этому же id

 Для удаления директории поле path в DirectoryUpdate не заполняется
 Удаление файла происходит так же, как и удаление директории:
 	FileUpdate с незаполненным enc_filename
 При удалении директории отправляется один OkUpdate.
 Сервер предполагает что клиент самостоятельно удалит вложенное дерево.

 checkpoint: средство для определения сервером продвижения пользователя по логу
 	изменений. Клиент должен хранить отдельный checkpoint для каждой rootdir

 * Последовательности
 Последовательность авторизации:
 S: ReqAuth
 C: Auth
 S: [Ok|Error|Pending]

 Последовательность инициализации:
 до момента отправки WantSync клинтом сообщения об обновлении не отсылаются
 C: WantSync (id = 30, session_id = 400)
 S: RootdirUpdate (id = 31, session_id = 400, no = 1, max = 3)
 S: DirectoryUpdate (id = 32, session_id = 400, no = 2, max = 3)
 S: (DirectoryUpdate)
 S: ...
 S: FileUpdate (id = 33, session_id = 400, no = 2, max = 3)
 S: (FileUpdate)
 S: End (id = 34, session_id = 400)
 ...

 Создание/удаление/переименование директории:
 C: DirectoryUpdate
 S: OkUpdate

 Последовательность записи:
 C: WriteAsk (id = 1000)
 S: OkWrite (id = 1000, session_id = 2344)
 C: xfer (session_id = 2344)
 C: xfer (session_id = 2344)
 ...
 C: End (id = 301, session_id = 2344)
 S: Ok (id = 301)
 C: WriteAsk...
 S: OkWrite...
 C: xfer...
 C: End...
 S: Ok...
 ...
 C: FileMeta (id = 1002)
 S: OkUpdate (id = 1002)

 Последовательность чтения:
 C: ReadAsk (id = 2051)
 S: OkRead (id = 2051, session_id = 331)
 S: xfer (id = 440, session_id = 331)
 S: xfer (id = 441, session_id = 331)
 ...
 S: End (id = 445, session_id = 331)

 Получение количества чанков и информацию по файлу:
 C: QueryChunks (id = 100, session_id = 200)
 S: FileMeta (id = 100)
 S: ResultChunk (id = 101, session_id = 200, chunk_no = 1, chunk_max = 3)
 S: ResultChunk (id = 102, session_id = 200, chunk_no = 2, chunk_max = 3)
 S: ResultChunk (id = 103, session_id = 200, chunk_no = 3, chunk_max = 3)
 S: End(id = 104, session_id = 200)

 Получение списка ревизий
 C: QueryRevisions (id = 107, session_id = 201, depth = 3, offset = 0)
 S: Ok (id = 107)
 S: ResultRevision (id = 108, session_id = 201, rev_no = 1, rev_max = 3)
 S: ResultRevision (id = 109, session_id = 201, rev_no = 2, rev_max = 3)
 S: ResultRevision (id = 110, session_id = 201, rev_no = 3, rev_max = 3)
 S: End(id = 111, session_id = 201)
*/

enum Type {
	tPing = 1;
	tPong = 2;
	tError = 3;
	tOk = 4;
	tPending = 5;
	tReqAuth = 6;
	tAuth = 7;
	txfer = 8;
	tReadAsk = 9;
	tWriteAsk = 10;
	tEnd = 11;
	tOkWrite = 12;
	tFileUpdate = 13;
	tRenameChunk = 14;
	tQueryChunks = 15;
	tResultChunk = 16;
	tQueryRevisions = 17;
	tResultRevision = 18;
	tDirectoryUpdate = 19;
	tFileMeta = 20;
	tWantSync = 21;
	tOkUpdate = 22;
	tRootdirUpdate = 23;
	tOkRead = 24;
	tRoar = 25;
}

/*

 Время в Ping/Pong указывается от начала эры Unix
 C: Ping
 S: Pong
 клиент указывает в Ping время генерации сообщения,
 а сервер время обработки
*/
message Pong {
	required uint64 id = 1;
	/* время из Ping */
	required uint64 sec = 2;
	required uint32 usec = 3;
	/* время на удалённом пире */
	required uint64 peer_sec = 4;
	required uint64 peer_usec = 5;
}

message Ping {
	required uint64 id = 1;
	/* секунды и микросекунды */
	required uint64 sec = 2;
	required uint32 usec = 3;
}

enum ReqAuthType {
	tHash = 0;
	tUserPassword = 1;
	tUserToken = 2;
	tKey = 3;
}

/* предложение сервера авторизироваться:
 * ожидаемые ответы: Auth */
message ReqAuth {
	required uint64 id = 1;
	/* информационный текст для пользователя */
	optional string text = 5;
}

/* запрос клиента авторизации
 * ожидаемые ответы: Ok, Error,
 * Pending: информационное сообщение, авторизация принята,
 * 		но проверку выполнить прямо сейчас не получится
 */
message Auth {
	required uint64 id = 1;
	required string domain = 2;
	/* поля для авторизации, только хеш, юзер/пароль, ключ */
	optional string authToken = 4;
	optional string username = 5;
	optional string password = 6;
	optional bytes key = 7;
	required ReqAuthType authType = 8;

	/* идентификация устройства */
	required uint64 device_id = 14;

}

/* общие ответы
	в поле requestType указывается тип сообщения
	на которое генерируется ответ
 */
message Error {
	required uint64 id = 1 [default = 0];
	optional string message = 3;
	/* количество оставшихся попыток до применения санкций
	   полезно, к примеру, для Auth
	   Если указан 0, то продолжение работы невозможно
	   в остальных случаях или используется счётчик или поле не указывается
	 */
	optional uint32 remain = 4;
}

message Ok {
	required uint64 id = 1;
	/* сообщение как предупреждение */
	optional string message = 10;
}

/* подобный запрос уже выполняется
 или используется в качестве альтернативы пингу сервером к клиенту
 указывает на то, что запрос принят к обработке,
 но быть выполненым сейчас не может, дальнейшие распоряжения прийдут позже
 */
message Pending {
	required uint64 id = 1 [default = 0];
	/* стринги отладки */
	optional string debug = 999;
}

/* отмена операции */
message Cancel {
	required uint64 id = 1 [default = 0];
	optional string message = 2;
}

/*
	Переименование, удаление файлов
	Ответы:
		OkUpdate, Error, Pending
*/
message FileUpdate {
	required uint64 id = 1 [default = 0];

	/* идентификация файла по трём полям */
	required string rootdir_guid = 3;
	required string file_guid = 4;

	/* опциональные значения
	 если не переименование (enc_filename)
	 и не перемещение (directory_guid), то это удаление
	 */
	optional string enc_filename = 50;
	optional string directory_guid = 53;
	/* приходит только от сервера клиенту
	  при обновлении ревизии файла (enc_filename и directory_guid пустые)
	 */
	optional string revision_guid = 54;

	/* отправляется только сервером клиенту, содержит чекпоинт лога */
	optional uint64 checkpoint = 100;

	/* для ответа на WantSync */
	optional uint32 session_id = 201;
	/* количество и номер в пределах сессии */
	optional uint32 no = 202;
	optional uint32 max = 203;
}


/*
 Присылается после отправки всех чанков
 ревизии файла
 Ответы:
	OkUpdate: Всё нормально, можно продолжать
	Error: отмена
 */
message FileMeta {
	required uint64 id = 1 [default = 0];

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string revision_guid = 5;
	required string directory_guid = 6;
	/* количество чанков в файле */
	required uint32 chunks = 10;
	/* эти поля не обязательно отправлять с новой ревизией,
	  но если сервер не найдёт старые записи файла, в которых ключ есть,
	  то можно словить Error
	 */
	optional string enc_filename = 50;
	optional bytes key = 52;

	/* может быть пустым если файл новый */
	optional string parent_revision_guid = 87;
}

/*
 * Запрос разрешения на запись
 * ответы:
 *  Error: неудача
 *  OkWrite: запись разрешена
*/
message WriteAsk {
	required uint64 id = 1 [default = 0];
	/* название рутдиры */
	required string rootdir_guid = 3;
	required string file_guid = 5;
	required string chunk_guid = 6;
	required string revision_guid = 7;
	/* sha256 хеш чанка */
	required bytes chunk_hash = 10;

	/* требуемое пространство в байтах для сохранения,
		пространство резервируется и идентификатор резервации указывается
		в поле session_id в ответе OkWrite
	*/
	required uint32 size = 20;
	required uint32 offset = 21;

}

message OkWrite {
	required uint64 id = 1 [default = 0];

	/*
		Номер сессии, внутри которой передаются куски чанка
		этот id используется в сообщении xfer, для того, что бы можно
		было передавать несколько файлов одновременно
	*/
	required uint32 session_id = 2;

}

/*
   Предложение сервера или клиента завершить сессию
*/
message End {
	required uint64 id = 1 [default = 0];
	/* важное поле: идентификатор запрошенного пространства
	   при запросе записи резервируется пространство
	   и этот идентификатор нужен для последующей записи в это пространство
	   */
	required uint32 session_id = 2;

	/* опциональное поле-контролёр: сколько пакетов было отослано в сессии */
	optional uint32 packets = 4;
}

/* ответ на запрос чтения */
message OkRead {
	required uint64 id = 1 [default = 0];
	
	required uint32 session_id = 2;

	required uint32 size = 5;
	required uint32 offset = 6;
}

/* 
 	Передача куска чанка.
	Если ошибок во время записи не произошло, подтверждение не отсылается.
	Иначе возвращается Error
 */
message xfer {
	required uint64 id = 1 [default = 0];
	/* идентификатор сессии передачи */
	required uint32 session_id = 2;
	/* смещение в чанке */
	required uint64 offset = 4;
	required bytes data = 6;
}

/* чтение */

/*
 запрос на чтение,
 возможные ответы:
 Error: невозможно начать передау
 Write: передача
*/
message ReadAsk {
	required uint64 id = 1 [default = 0];

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string chunk_guid = 5;
}

message QueryRevisions {
	required uint64 id = 1 [default = 0];

	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	required string file_guid = 4;

	required uint32 depth = 5 [default = 3];
}

message ResultRevision {
	required uint64 id = 1 [default = 0];

	required uint32 session_id = 2;

	required string revision_guid = 3;
	/* аналог к ResultChunk.chunk_no/ResultChunk.chunk_max */
	required uint32 rev_no = 5;
	required uint32 rev_max = 6;
	
	optional string parent_revision_guid = 10;
}

/* запрос чанков для ревизии revision_guid
 Ответы:
 	FileMeta, Error
 */
message QueryChunks {
	required uint64 id = 1 [default = 1];

	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	required string file_guid = 4;
	required string revision_guid = 5;
}

/* ответ на QueryChunks */
message ResultChunk {
	required uint64 id = 1 [default = 1];

	required uint32 session_id = 2;

	required string chunk_guid = 5;
	/* общее количество подобных сообщений и номер текущего сообщения  */
	required uint32 chunk_no = 7;
	required uint32 chunk_max = 8;
	
	required bytes chunk_hash = 10;
}

/* используется для переноса чанка из другой ревизии в указанную */
message RenameChunk {
	required uint64 id = 1 [default = 0];
	required string rootdir_guid = 2;
	required string file_guid = 3;
	required string chunk_guid = 4;
	/* целевой гуид */
	required string to_chunk_guid = 5; 
	required string to_revision_guid = 6;
}

/* извещения
 * Извещения отправляются сервером клиенту
 * в случае отсутсвия поля id ответ не требуется
 */

/*
	сообщение о озменениях в структуре каталогов
 */
message DirectoryUpdate {
	required uint64 id = 1;
	required string rootdir_guid = 2;
	/* гуид директории */
	required string directory_guid = 3;

	/* путь директории
	 имя указывается или для новых директорий или для переименования,
	 если не указан -- директория удаляется
	 */
	optional string path = 4;

	/* отправляется только сервером */
	optional uint64 checkpoint = 100;

	/* поля для ответа сервера на WantSync */
	optional uint32 session_id = 201;
	/* количество и номер в пределах сессии */
	optional uint32 no = 202;
	optional uint32 max = 203;
}

/* TODO:
   3. добавить обратку коллизий
   2. нотификация
   1. Мета (директории, хеши, всё такое)
 */

/*
	Хотет синка
	нотификационное сообщение, в ответ Ok или Error
	после чего пачками приходят сообщения Directory и FileUpdate
	ответы: Ok, Error
   */
message WantSync {
	required uint64 id = 1 [default = 0];

	/*
		WantSync должен быть на каждый rootdir,
		если rootdir не указан,
		то возвращается лог создания rootdir (список рутдир)
	*/
	optional string rootdir_guid = 3;
	/* чекпоинт для лога */
	required uint64 checkpoint = 5 [default = 0];

	/* номер сессии для DirectoryUpdate/FileUpdate */
	required uint32 session_id = 10;
}

/*
	положительный ответ для FileUpdate и DirectoryUpdate
  */
message OkUpdate {
	required uint64 id = 1 [default = 0];
	/* id состояния, в которое попала запись */
	required uint64 checkpoint = 5;

	/* сообщение как и для Ok */
	optional string message = 10;
}


/* от сервера к клиенту
	извещение о обновлении состояния Rootdir
  */
message RootdirUpdate {
	required uint64 id = 1 [default = 0];
	required string rootdir_guid = 24;
	
	optional string name = 90;

	optional uint64 checkpoint = 100;

	optional uint32 session_id = 201;
	optional uint32 no = 202;
	optional uint32 max = 203;
}

/* сообщение от клиента другим клиентам (в рамках одной учётной записи)
	если device_to не указан, то сообщение
	доставляется всем подключённым клиентам

	Возможные ответы:
	Ok, Error
	*/
message Roar {
	required uint64 id = 1 [default = 0];
	required uint64 device_id_from = 21;
	optional uint64 device_id_to = 22;

	/* если не использовать это поле,
	   то сообщение рассылается в пределах пользователя,
	   от которого сообщение было послано
	   */
	optional string user_to = 30;

	required bytes message = 50;
}

