package fep;
option optimize_for = SPEED;
/*
 * |a|a|b|b|b|_|
 *  ^   ^__________ payload size
 *  |_________ packet type
 * _ - are reserved
 * all values in BE bytes order
 */


/*
 * Особенности
 Для записи и чтения еденица передачи: чанк
 На любой из запросов к севреру может прийти ответ Pending с тем же id
  Данный ответ является лишь указанием на то, что сервер принял запрос,
  но обработает его позже, следует ждать дальнейших указаний по этому же id

 * Последовательности
 Последовательность авторизации:
 S: ReqAuth
 C: Auth
 S: [Ok|Error|Pending]

 Последовательность инициализации:
 C: ReqInit
 S: ...
 
 Последовательность записи:
 C: WriteAsk (id = 1000)
 S: WriteOk (id = 1000, session_id = 2344)
 C: xfer (session_id = 2344)
 C: xfer (session_id = 2344)
 ...
 C: End (id = 1001, session_id = 2344)
 S: Ok (id = 1001)

 Последовательность чтения:
 C: ReadAsk (id = 1000, session_id = 222)
 S: xfer (session_id = 222)
 S: xfer (session_id = 222)
 ...
 S: End(id = 1000, session_id = 222)

 Серверу не имеет значения, был ли доставлен файл до клиента,
 Потому завершающее сообщение отправляется с Id == 0 и не требует ответа 

*/

enum Type {
	tPing = 1;
	tPong = 2;
	tError = 3;
	tOk = 4;
	tPending = 5;
	tReqAuth = 6;
	tAuth = 7;
	txfer = 8;
	tReadAsk = 9;
	tWriteAsk = 10;
	tEnd = 11;
	tWriteOk = 12;
	tFileUpdate = 13;
}

/*

 Время в Ping/Pong указывается от начала эры Unix
 C: Ping
 S: Pong
 клиент указывает в Ping время генерации сообщения,
 а сервер время обработки
*/
message Pong {
	required uint64 id = 1;
	/* время из Ping */
	required uint64 sec = 2;
	required uint32 usec = 3;
	/* время на удалённом пире */
	required uint64 peer_sec = 4;
	required uint64 peer_usec = 5;
}

message Ping {
	required uint64 id = 1;
	/* секунды и микросекунды */
	required uint64 sec = 2;
	required uint32 usec = 3;
}

enum ReqAuthType {
	tHash = 0;
	tUserPassword = 1;
	tUserToken = 2;
	tKey = 3;
}

/* предложение сервера авторизироваться:
 * ожидаемые ответы: Auth */
message ReqAuth {
	required uint64 id = 1;
	/* информационный текст для пользователя */
	optional string text = 5;
}

/* запрос клиента авторизации
 * ожидаемые ответы: Ok, Error,
 * Pending: информационное сообщение, авторизация принята,
 * 		но проверку выполнить прямо сейчас не получится
 */
message Auth {
	required uint64 id = 1;
	required string domain = 2;
	/* поля для авторизации, только хеш, юзер/пароль, ключ */
	optional string authToken = 4;
	optional string username = 5;
	optional string password = 6;
	optional bytes key = 7;
	required ReqAuthType authType = 8;
}

/* общие ответы
	в поле requestType указывается тип сообщения
	на которое генерируется ответ
 */
message Error {
	required uint64 id = 1 [default = 0];
	optional string message = 3;
	/* количество оставшихся попыток до применения санкций
	   полезно, к примеру, для Auth
	   Если указан 0, то продолжение работы невозможно
	   в остальных случаях или используется счётчик или поле не указывается
	 */
	optional uint32 remain = 4;
}

message Ok {
	required uint64 id = 1;
}

/* подобный запрос уже выполняется
 или используется в качестве альтернативы пингу сервером к клиенту
 указывает на то, что запрос принят к обработке,
 но быть выполненым сейчас не может, дальнейшие распоряжения прийдут позже
 */
message Pending {
	required uint64 id = 1 [default = 0];
	/* стринги отладки */
	optional string debug = 999;
}

/* отмена операции */
message Cancel {
	required uint64 id = 1 [default = 0];
	optional string message = 2;
}

/* обновление файла
 присылается сервером клиенту или клиентом серверу в случае обновления
 ревизии файла
 Ответы:
	Ok: Всё нормально, можно продолжать
	Error: отмена
 */
message FileUpdate {
	required uint64 id = 1 [default = 0];

	required string rootdir_guid = 3;
	required string file_guid = 4;
	/* новое количество чанков в файле
	   при удалении отсылается значение = 0 */
	required uint32 chunks = 5;
}

/*
 * Запрос разрешения на запись
 * ответы:
 *  Error: неудача
 *  WriteOk: запись разрешена
*/
message WriteAsk {
	required uint64 id = 1 [default = 0];
	/* требуемое пространство в байтах для сохранения,
		пространство резервируется и идентификатор резервации указывается
		в поле session_id в ответе WriteOk
	*/
	required uint64 size = 2;
	/* название рутдиры */
	required string rootdir_guid = 3;
	required string file_guid = 5;
	required string chunk_guid = 6;
	/* позиция в файле */
}

message WriteOk {
	required uint64 id = 1 [default = 0];

	/*
		Номер сессии, внутри которой передаются куски чанка
		этот id используется в сообщении xfer, для того, что бы можно
		было передавать несколько файлов одновременно
	*/
	required uint32 session_id = 2;

}

/* Ответ сервера на запрос записи */
message End {
	/* для отправки файл сервер -> клиент подтверждение
	   получения не обязательно, клиент должен сам решать,
	   получил ли он всё или чего-то не хватает */
	optional uint64 id = 1 [default = 0];
	/* важное поле: идентификатор запрошенного пространства
	   при запросе записи резервируется пространство
	   и этот идентификатор нужен для последующей записи в это пространство
	   */
	required uint32 session_id = 2;
	/* в конце передачи сообщаем контрольную сумму, или не сообщаем */
	optional string crc = 10;
}

/* На Write подтверждение бессмысленно слать, потому шлём потоком,
   после чего отсылается WriteOk  */
message xfer {
	required uint32 session_id = 1;
	/* номер текущего сегмента и общее количество сегментов */
	required uint32 segment = 4;
	required uint32 segments = 5;
	required bytes data = 6;
}

/* чтение */

/*
 запрос на чтение,
 возможные ответы:
 Error: невозможно начать передау
 Write: передача
*/
message ReadAsk {
	required uint64 id = 1 [default = 0];
	/* аналогично записи, резервируемая область у клиента */
	required uint32 session_id = 2;

	required string rootdir_guid = 3;
	/* размер сегментов в байтах */
	required uint32 segment_size = 4;

	required string chunk_guid = 5;
}


/* */
message RenameChunk {
	required uint64 id = 1 [default = 0];
	required string rootdir_guid = 2;
	required string file_guid = 3;
	required string chunk_guid = 4;
	/* целевой гуид */
	required string to_chunk_guid = 5; 
}

/* извещения
 * Извещения отправляются сервером клиенту
 * в случае отсутсвия поля id ответ не требуется
 */

/*
	Извещение клиенту, что пришёл чанк обновился
  	ответ не требуется 
 */
message ChunkUpdate {
	
}

/* TODO:
   3. добавить обратку коллизий
   2. нотификация
   1. Мета (директории, хеши, всё такое)
 */

/*
TODO: добавить сообщение нотификации отдельных файлов
*/
