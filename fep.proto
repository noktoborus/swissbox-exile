package fep;

/*
 * |a|a|b|b|b|_|
 *  ^   ^__________ payload size
 *  |_________ packet type
 * _ - are reserved
 * all values in BE bytes order
 */


/*
 * Особенности
 Для записи и чтения еденица передачи: чанк
 На любой из запросов к севреру может прийти ответ Pending с тем же id
  Данный ответ является лишь указанием на то, что сервер принял запрос,
  но обработает его позже, следует ждать дальнейших указаний по этому же id

 * Последовательности
 Последовательность авторизации:
 S: ReqAuth
 C: Auth
 S: [Ok|Error|Pending]

 Последовательность инициализации:
 C: ReqInit
 S: ...
 
 Последовательность записи:
 C: WriteAsk (id = 1000)
 S: WriteOk (id = 1000, space = 2344)
 C: xfer (space = 2344)
 C: xfer (space = 2344)
 ...
 C: End (id = 1001, space = 2344)
 S: Ok (id = 1001)

 Последовательность чтения:
 C: ReadAsk (id = 1000, space = 222)
 S: xfer (space = 222)
 S: xfer (space = 222)
 ...
 S: End(id = 0, space = 222)

 Серверу не имеет значения, был ли доставлен файл до клиента,
 Потому завершающее сообщение отправляется с Id == 0 и не требует ответа 

*/

enum Type {
	tPing = 1;
	tPong = 2;
	tError = 3;
	tOk = 4;
	tPending = 5;
	tReqAuth = 6;
	tAuth = 7;
}

message Pong {
	required uint64 id = 1;
	required uint64 timestamp = 2;
	required uint32 usecs = 3;
}

message Ping {
	required uint64 id = 1;
	required uint64 timestamp = 2;
	required uint32 usecs = 3;
}


enum ReqAuthType {
	tHash = 0;
	tUserPassword = 1;
	tKey = 2;
}

/* type: 3 */
/* предложение сервера авторизироваться:
 * ожидаемые ответы: Auth */
message ReqAuth {
	enum Target {
		tInternal = 0; /* авторизация внутри коробки */
		tLDAP = 1; /* авторизация требуется для адаптера LDAP */
		tSwiss = 2; /* авторизация для адаптера свистка */
		tOther = 100; /* запрос непонятно для чего, куда-то наружу */
	};
	required uint64 id = 1;
	required string domain = 2;
	required ReqAuthType type = 3;
	required Target target = 4;
	/* информационный текст для пользователя */
	optional string text = 5;
}

/* type: 4 */
/* запрос клиента авторизации
 * ожидаемые ответы: Ok, Error,
 * Pending: информационное сообщение, авторизация принята,
 * 		но проверку выполнить прямо сейчас не получится
 */
message Auth {
	required uint64 id = 1;
	required string domain = 2;
	/* поля для авторизации, только хеш, юзер/пароль, ключ */
	optional string authToken = 4;
	optional string username = 5;
	optional string password = 6;
	required ReqAuthType authType = 7;
}

/* общие ответы
	в поле requestType указывается тип сообщения
	на которое генерируется ответ
 */
message Error {
	required uint64 id = 1 [default = 0];
	optional string message = 3;
	/* количество оставшихся попыток до применения санкций
	   полезно, к примеру, для Auth
	   Если указан 0, то продолжение работы невозможно
	   в остальных случаях или используется счётчик или поле не указывается
	 */
	optional uint32 remain = 4;
}

message Ok {
	required uint64 id = 1;
}

/* подобный запрос уже выполняется
 или используется в качестве альтернативы пингу сервером к клиенту
 указывает на то, что запрос принят к обработке,
 но быть выполненым сейчас не может, дальнейшие распоряжения прийдут позже
 */
message Pending {
	required uint64 id = 1 [default = 0];
	/* стринги отладки */
	optional string debug = 999;
}

/* отмена операции */
message Cancel {
	required uint64 id = 1 [default = 0];
	optional string message = 2;
}


/*
 * Запрос разрешения на запись
 * ответы:
 *  Error: неудача
 *  WriteOk: запись разрешена
*/
message WriteAsk {
	required uint64 id = 1 [default = 0];
	/* требуемое пространство в байтах для сохранения */
	required uint64 reqspace = 2;
	/* название рутдиры */
	required string rootdir_guid = 3;
	required string file_guid = 5;
	required string revision_guid = 6;
}

/* Ответ сервера на запрос записи */
message End {
	/* для отправки файл сервер -> клиент подтверждение
	   получения не обязательно, клиент должен сам решать,
	   получил ли он всё или чего-то не хватает */
	optional uint64 id = 1 [default = 0];
	/* важное поле: идентификатор запрошенного пространства
	   при запросе записи резервируется пространство
	   и этот идентификатор нужен для последующей записи в это пространство
	   */
	required uint32 space = 2;
	/* в конце передачи сообщаем контрольную сумму, или не сообщаем */
	optional string crc = 10;
}

/* На Write подтверждение бессмысленно слать, потому шлём потоком,
   после чего отсылается WriteOk  */
message xfer {
	required uint32 space = 1;
	/* номер текущего сегмента и общее количество сегментов */
	required uint32 segment = 4;
	required uint32 segments = 5;
	required bytes data = 6;
}

/* чтение */

/*
 запрос на чтение,
 возможные ответы:
 Error: невозможно начать передау
 Write: передача
*/
message ReadAsk {
	required uint64 id = 1 [default = 0];
	/* аналогично записи, резервируемая область у клиента */
	required uint32 space = 2;

	required string rootdir = 3;
	/* размер сегментов в байтах */
	required uint32 segment_size = 4;

	required string chunk_guid = 5;
	required string revision_guid = 6;
}

/* извещения
 * Извещения отправляются сервером клиенту
 * в случае отсутсвия поля id ответ не требуется
 */

/*
	Извещение клиенту, что пришёл чанк обновился
  	ответ не требуется 
 */
message ChunkUpdate {
	
}

/* TODO: добавить обратку коллизий */

/*
TODO: добавить сообщение нотификации отдельных файлов
*/
